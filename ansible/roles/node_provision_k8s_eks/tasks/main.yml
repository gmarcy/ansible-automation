---

- name: Set facts used in this role
  set_fact:
    k8s_version: "{{ hostvars['k8s-provisioner']['options']['k8s_version'] }}"
    cluster_name: "{{ hostvars['k8s-provisioner']['cluster_name'] }}"
    cluster_domain: "{{ hostvars['k8s-provisioner']['cluster_domain'] }}"
    cluster_fqdn: "{{ hostvars['cluster-facts']['cluster_fqdn'] }}"
    k8s_infra_hostname: "{{ hostvars['k8s-provisioner']['k8s_infra_hostname'] }}"
    k8s_infra_publicip: "{{ hostvars['k8s-provisioner']['k8s_infra_publicip'] }}"
    k8s_infra_privateip: "{{ hostvars['k8s-provisioner']['k8s_infra_privateip'] }}"

- name: Set registry facts used in this role
  set_fact:
    registry_url: "{{ k8s_infra_hostname + '.' + cluster_domain + ':5000' }}"
    registry_username: registry
    registry_password: p@ssw0rd

- name: Check for next step completed marker
  stat:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_packages_installed' }}"
  register: _result_packages_installed
  delegate_to: 'cluster-facts'
  run_once: true

- when: not _result_packages_installed.stat.exists
  block:

    - name: Install common requirements
      package:
        name:
          - wget
          - nano
          - python3
          - python3-pip
          - which
          - jq
          - yum-utils
        state: present
      register: _result
      changed_when: "_result.rc == 0"

    - name: Install yq
      command: python3 -m pip install --upgrade yq
      register: _result
      changed_when: "_result.rc == 0"

    - name: Install kubernetes
      command: python3 -m pip install --upgrade kubernetes
      register: _result
      changed_when: "_result.rc == 0"

    #- name: Update packages
    #  package:
    #    name: "*"
    #    state: latest
    #  register: _result_update_packages

- name: Create marker for packages_installed
  file:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_packages_installed' }}"
    state: touch
    mode: '0644'
  delegate_to: 'cluster-facts'
  run_once: true
  changed_when: false

- name: Check for existing /etc/containers/registries.conf
  stat:
    path: /etc/containers/registries.conf
  register: _result

- when: not _result.stat.exists
  block:

    - name: Create /etc/containers folder
      file:
        path: /etc/containers
        state: directory
        mode: '0755'

    - name: Create /etc/containers/registries.conf
      file:
        path: /etc/containers/registries.conf
        state: touch
        mode: '0644'

- name: Add insecure registry
  blockinfile:
    path: /etc/containers/registries.conf
    block: |
      [[registry]]
      location = "{{ registry_url }}"
      insecure = true

- when: inventory_hostname == k8s_infra_hostname
  name: Setup of the infra node
  block:

    #
    # Kubernetes config
    #

    - name: Fetch the EKS default release branch
      uri:
        url: https://raw.githubusercontent.com/aws/eks-distro/main/release/DEFAULT_RELEASE_BRANCH
        return_content: true
      register: _result

    - name: Set EKS kubernetes major-minor fact
      set_fact:
        eks_kubernetes_major_minor: "{{ _result.content | trim }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - when: eks_revision is not defined
      block:

        - name: Discover the revision number for eks
          uri:
            url: "{{ 'https://raw.githubusercontent.com/aws/eks-distro/main/release/' + hostvars['k8s-provisioner']['eks_kubernetes_major_minor'] + '/production/RELEASE' }}"
            return_content: true
          register: _result

        - name: Set eks_revision fact
          set_fact:
            eks_revision: "{{ _result.content | trim }}"
          delegate_to: 'k8s-provisioner'
          delegate_facts: true

    - name: Set eks_major_minor_revision fact
      set_fact:
        eks_major_minor_revision: "{{ hostvars['k8s-provisioner']['eks_kubernetes_major_minor'] + '-eks-' + (hostvars['k8s-provisioner']['eks_revision'] | string) }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Discover the git tag for eks
      uri:
        url: "{{ 'https://raw.githubusercontent.com/aws/eks-distro/main/projects/kubernetes/release/' + hostvars['k8s-provisioner']['eks_kubernetes_major_minor'] + '/GIT_TAG' }}"
        return_content: true
      register: _result

    - name: Set EKS string facts
      set_fact:
        eks_kubernetes_gittag: "{{ (_result.content | trim) + '-eks-' + hostvars['k8s-provisioner']['eks_kubernetes_major_minor'] + '-' + (hostvars['k8s-provisioner']['eks_revision'] | string) }}"
        eks_kubernetes_dirname: "kubernetes-{{ hostvars['k8s-provisioner']['eks_kubernetes_major_minor'] }}"
        eks_kubernetes_filename: "kubernetes-{{ hostvars['k8s-provisioner']['eks_major_minor_revision'] }}.yaml"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Set complete EKS kubernetes version
      set_fact:
        eks_kubernetes_version: "{{ hostvars['k8s-provisioner']['eks_kubernetes_major_minor'].replace('-','.') }}"
        eks_distro_url: "{{ 'https://distro.eks.amazonaws.com/' + hostvars['k8s-provisioner']['eks_kubernetes_dirname'] + '/' + hostvars['k8s-provisioner']['eks_kubernetes_filename'] }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Load the release information from the EKS distro release resource
      uri:
        url: "{{ hostvars['k8s-provisioner']['eks_distro_url'] }}"
        return_content: true
      register: _result

    - name: Set eks_release_info fact
      set_fact:
        eks_release_info: "{{ _result.content | from_yaml | combine({'value': omit}) }}"
        eks_release_info_kubernetes: "{{ (_result.content | from_yaml)['status']['components'] | selectattr('name','==','kubernetes') | first }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Discover full version of Kubernetes that will be deployed
      set_fact:
        eks_kubernetes_version_full: "{{ hostvars['k8s-provisioner']['eks_release_info_kubernetes']['gitTag'] | regex_replace('^v','') }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Fetch all of the archive uris for kubernetes commands
      set_fact:
        archive_uris: "{{ archive_uris | default({}) | combine({item: asset['archive']['uri']}) }}"
      loop:
      - 'kubectl'
      - 'kubeadm'
      - 'kubelet'
      vars:
        asset: "{{ hostvars['k8s-provisioner']['eks_release_info_kubernetes']['assets'] | selectattr('name','==','bin/linux/amd64/' + item) | first }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

- name: Check for next step completed marker
  stat:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_nodes_configured' }}"
  register: _result_nodes_configured
  delegate_to: 'cluster-facts'
  run_once: true

- when: not _result_nodes_configured.stat.exists and inventory_hostname in groups['cluster_nodes']
  name: Configure guest node vms
  block:

    #- name: Make NetworkManager stop updating resolv.conf
    #  lineinfile:
    #    dest: "/etc/NetworkManager/NetworkManager.conf"
    #    insertafter: '^\[main\]'
    #    state: present
    #    line: 'dns=none'

    #- name: Restart NetworkManager
    #  service:
    #    name: NetworkManager
    #    state: restarted

    #- name: Get resolv lines
    #  slurp:
    #    src: /etc/resolv.conf
    #  register: _result_resolv_conf

    #- name: Add the local DNS server as a local resolver when not empty
    #  lineinfile:
    #    path: /etc/resolv.conf
    #    line: "nameserver {{ kubeinit_bind_service_address }}"
    #    insertbefore: nameserver.*
    #  when: (_result_resolv_conf.content | b64decode).splitlines() | length > 0

    #- name: Add the local DNS server as a local resolver when empty
    #  lineinfile:
    #    path: /etc/resolv.conf
    #    line: "nameserver {{ kubeinit_bind_service_address }}"
    #  when: (_result_resolv_conf.content | b64decode).splitlines() | length == 0

    #- name: Add the local DNS server as a local resolver
    #  lineinfile:
    #    path: /etc/resolv.conf
    #    line: "nameserver {{ kubeinit_dns_public }}"
    #    insertafter: nameserver.*

    - name: Disable SWAP
      command: swapoff -a
      register: _result

    #- name: Resize root partition
    #  shell: |
    #    echo 'Reclaim space for root partition'
    #    growpart /dev/vda 1
    #    xfs_growfs /dev/vda1
    #  args:
    #    executable: /bin/bash
    #  register: _result
    #  changed_when: "_result.rc == 0"

    - name: Enable kernel modules
      shell: |
        modprobe br_netfilter
        echo br_netfilter > /etc/modules-load.d/br_netfilter.conf
        modprobe overlay
        echo overlay > /etc/modules-load.d/overlay.conf
      args:
        executable: /bin/bash
      register: _result
      changed_when: false

    - name: Enable IP forward
      lineinfile:
        path: '/etc/sysctl.conf'
        regexp: '^net.ipv4.ip_forward *='
        line: 'net.ipv4.ip_forward = 1'

    - name: Enable bridge-nf-call-iptables
      lineinfile:
        path: '/etc/sysctl.conf'
        regexp: '^net.bridge.bridge-nf-call-iptables *='
        line: 'net.bridge.bridge-nf-call-iptables = 1'

    - name: Load sysctl configuration
      command: sysctl -p
      register: _result
      changed_when: false

    #
    # cri-o repos
    #

    - name: Download cri-o (kubeinit) repos
      get_url:
        url: https://download.opensuse.org/repositories/home:/kubeinit/CentOS_9_Stream/home:kubeinit.repo
        dest: /etc/yum.repos.d/kubeinit.repo
        mode: '0644'
      register: _result

    #
    # cri-o config
    #

    - name: Install the latest version of cri-o
      package:
        name: cri-o
        state: present

    - name: Install the latest version of crun
      package:
        name: crun
        state: present

    - name: Make sure cri-o binary is reachable and the configuration is correct
      shell: |
        # Make sure crio binary is reachable
        ln -s /usr/bin/crio /usr/local/bin/crio
        cp /etc/crio/crio.conf /etc/crio/crio.conf.backup
        sed -i s/^.*default_runtime\ =\ .*$/default_runtime\ =\ \"crun\"/g /etc/crio/crio.conf
        # There is no example config for crun anymore
        # sed -i "s/^\#\[crio\.runtime\.runtimes\.crun.*\]/[crio.runtime.runtimes.crun]/g" /etc/crio/crio.conf
        cat << EOF >> /etc/crio/crio.conf
        [crio.runtime.runtimes.crun]
        runtime_path = "/usr/bin/crun"
        runtime_type = "oci"
        runtime_root = "/run/crun"
        EOF
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"

    - name: Enable/start/status cri-o
      shell: |
        systemctl enable crio
        systemctl start crio
        systemctl status crio
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"

    - name: Install requirements
      package:
        name:
          - device-mapper-persistent-data
          - lvm2
        state: present

- name: Create marker for nodes_configured
  file:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_nodes_configured' }}"
    state: touch
    mode: '0644'
  delegate_to: 'cluster-facts'
  run_once: true
  changed_when: false

- name: Check for next step completed marker
  stat:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_kubernetes_commands' }}"
  register: _result_kubernetes_commands
  delegate_to: 'cluster-facts'
  run_once: true

- when: not _result_kubernetes_commands.stat.exists
  block:

    #
    # kubernetes repos
    #

    - name: Remove repo before adding it
      file:
        path: /etc/yum.repos.d/kubernetes.repo
        state: absent

    - name: Creating a repository file for Kubernetes
      file:
        path: /etc/yum.repos.d/kubernetes.repo
        state: touch
        mode: '0644'

    - name: Adding repository details in Kubernetes repo file.
      blockinfile:
        path: /etc/yum.repos.d/kubernetes.repo
        block: |
         [kubernetes]
         name=Kubernetes
         baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-$basearch
         enabled=1
         gpgcheck=1
         repo_gpgcheck=1
         gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
         exclude=kubelet kubeadm kubectl

    - name: Install requirements
      command: dnf install -y {{ item }}-{{ hostvars['k8s-provisioner']['eks_kubernetes_version_full'] }} --disableexcludes=kubernetes
      loop: "{{ ['kubectl'] if inventory_hostname == k8s_infra_hostname else ['kubectl', 'kubeadm', 'kubelet'] }}"
      register: _result
      changed_when: "_result.rc == 0"

    - name: Install (replace) requirements
      shell: |
        wget -q {{ hostvars['k8s-provisioner']['archive_uris'][item] }}
        chmod +x {{ item }}
        mv ./{{ item }} $(which {{ item }})
      args:
        executable: /bin/bash
      loop: "{{ ['kubectl'] if inventory_hostname == k8s_infra_hostname else ['kubectl', 'kubeadm', 'kubelet'] }}"
      register: _result
      changed_when: "_result.rc == 0"

    - when: inventory_hostname in groups['cluster_nodes']
      name: Setup of the infra node
      block:

        - name: Enable kubelet
          systemd:
            state: restarted
            name: kubelet
            enabled: yes

        #- name: Update packages
        #  package:
        #    name: "*"
        #    state: latest
        #  register: _result_update_packages

- name: Create marker for kubernetes_commands
  file:
    path: "{{ hostvars['cluster-facts']['cluster_dir'] + '/.marker_kubernetes_commands' }}"
    state: touch
    mode: '0644'
  delegate_to: 'cluster-facts'
  run_once: true
  changed_when: false

- when: inventory_hostname == k8s_infra_hostname
  name: Setup of the infra node
  block:

    - name: Read existing certificate if exists
      slurp:
        src: ~/.kube/cluster-ca/ca-certificate.pem
      register: certificate

    - name: Set registry_cert fact
      set_fact:
        ca_cert: "{{ certificate.content | b64decode }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Read existing certificate if exists
      slurp:
        src: ~/.kube/registry/certs/certificate.pem
      register: certificate

    - name: Set registry_cert fact
      set_fact:
        registry_cert: "{{ certificate.content | b64decode }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

- name: Copy CA cert to pki directory
  copy:
    content: "{{ hostvars['k8s-provisioner']['ca_cert'] }}"
    dest: /etc/pki/ca-trust/source/anchors/ca.crt
    mode: 0644

- name: Copy registry cert to pki directory
  copy:
    content: "{{ hostvars['k8s-provisioner']['registry_cert'] }}"
    dest: /etc/pki/ca-trust/source/anchors/registry_cert.crt
    mode: 0644

- name: Insert the local registry auth details
  file:
    path: .docker
    state: directory
    mode: '0755'

- name: Create registry auth pullsecret file
  copy:
    content: |
      {{ hostvars['k8s-provisioner']['registry_pullsecret'] }}
    dest: ".docker/config.json"
    group: root
    owner: root
    mode: '0644'
    force: yes

- name: Update the CA certs files
  command: update-ca-trust extract
  register: _result
  changed_when: false

- when: inventory_hostname == k8s_infra_hostname
  name: Setup of the infra node
  block:

    - name: Check to see if mirror was already done
      uri:
        url: "{{ 'https://' + registry_url + '/v2/_catalog' }}"
        user: "{{ registry_username }}"
        password: "{{ registry_password }}"
      register: _result

    - name: Set registry_catalog fact
      set_fact:
        registry_catalog: "{{ _result.json }}"

    - when: registry_catalog['repositories'] | length == 0
      block:

        #
        # Configure local registry
        #

        - name: Install services requirements
          package:
            name: skopeo
            state: present

        - name: Set deployment_assets fact
          set_fact:
            deployment_assets: "{{ hostvars['k8s-provisioner']['eks_release_info']['status']['components'] | map(attribute='assets') | flatten }}"

        - name: Set deployment_images fact
          set_fact:
            deployment_images: "{{ deployment_assets | selectattr('type','==','Image') | map(attribute='image.uri') }}"

        - name: Add additional images
          set_fact:
            deployment_images: "{{ deployment_images | union([item]) }}"
          loop:
          - public.ecr.aws/eks-distro/kubernetes/kube-proxy-base:{{ hostvars['k8s-provisioner']['eks_kubernetes_gittag'] }}
          - public.ecr.aws/eks-distro/kubernetes/go-runner:{{ hostvars['k8s-provisioner']['eks_kubernetes_gittag'] }}

        - name: Mirror EKS container registry images to infra registry with path
          command: skopeo copy docker://{{ item }} docker://{{ registry_url }}/{{ path }} --dest-creds {{ registry_username }}:{{ registry_password }} --dest-tls-verify=false
          loop: "{{ deployment_images }}"
          vars:
            path: "{{ item | regex_replace('^public.ecr.aws/','') }}"

        - name: Mirror EKS container registry images to infra registry without path
          command: skopeo copy docker://{{ item }} docker://{{ registry_url }}/{{ no_path }} --dest-creds {{ registry_username }}:{{ registry_password }}
          loop: "{{ deployment_images }}"
          vars:
            no_path: "{{ item | regex_replace('^.*/','') }}"

- when: inventory_hostname == groups['master_nodes'][0]
  name: Setup specific to the first server node of the control plane
  block:

    - name: Check for existing ~/eks_controller_join_key
      stat:
        path: ~/eks_controller_join_key
      register: _result_controller_join_key

    - when: not _result_controller_join_key.stat.exists
      block:

        - name: Clean kubeadm
          shell: |
            set -eo pipefail
            kubeadm reset -f || true
            kubeadm config images list
            kubeadm config images list --image-repository {{ registry_url }}
            kubeadm config images list --kubernetes-version latest
          args:
            executable: /bin/bash
          environment:
            HTTP_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
            HTTPS_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
            NO_PROXY: "localhost,127.0.0.1,0.0.0.0,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.local,.svc"
          register: _result_kubeadm_init_output
          changed_when: "_result_kubeadm_init_output.rc == 0"

        - name: Fetch the coredns tag info
          uri:
            url: "{{ 'https://' + registry_url + '/v2/coredns/tags/list' }}"
            user: "{{ registry_username }}"
            password: "{{ registry_password }}"
          register: _result_coredns_tag_info
          delay: 5
          retries: 20
          until: _result_coredns_tag_info.status != -1

        - name: Fetch the etcd tag
          uri:
            url: "{{ 'https://' + registry_url + '/v2/etcd/tags/list' }}"
            user: "{{ registry_username }}"
            password: "{{ registry_password }}"
          register: _result_etcd_tag_info
          delay: 5
          retries: 20
          until: _result_etcd_tag_info.status != -1

        - name: Create the cluster init template
          copy:
            content: |
              apiVersion: kubeadm.k8s.io/v1beta3
              kind: ClusterConfiguration
              dns:
                imageRepository: "{{ registry_url }}"
                imageTag: {{ _result_coredns_tag_info.json.tags | first  }}
              etcd:
                local:
                  imageRepository: "{{ registry_url }}"
                  imageTag: {{ _result_etcd_tag_info.json.tags | first }}
              controlPlaneEndpoint: "{{ cluster_fqdn }}:6443"
              kubernetesVersion: "stable-{{ hostvars['k8s-provisioner']['eks_kubernetes_version'] }}"
              networking:
                podSubnet: 10.244.0.0/16
            dest: ~/kubeadm-config.yml
            mode: '0644'

        - name: Initialize Kubernetes cluster
          command: kubeadm init --upload-certs --config=kubeadm-config.yml
          environment:
            HTTP_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
            HTTPS_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
            NO_PROXY: "localhost,127.0.0.1,0.0.0.0,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.local,.svc"
          register: _result_kubeadm_init_output
          changed_when: "_result_kubeadm_init_output.rc == 0"

        - name: Get the controller join key
          set_fact:
            eks_controller_join_key: "{{ item | trim }}"
          loop: "{{ _result_kubeadm_init_output.stdout_lines | select('match', '.*--control-plane --certificate-key.*') }}"

        - name: Storing the controller join key to add the other controller nodes.
          copy:
            content: "{{ eks_controller_join_key }}"
            dest: ~/eks_controller_join_key
            mode: '0644'

    - name: Read the controller join key
      slurp:
        src: ~/eks_controller_join_key
      register: _result

    - name: Set eks_join_command fact
      set_fact:
        eks_controller_join_key: "{{ _result.content | b64decode }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Create kube directory
      file:
        path: ~/.kube
        state: directory
        mode: '0644'

    - name: Copy admin.conf to ~/.kube/config
      copy:
        src: '/etc/kubernetes/admin.conf'
        remote_src: true
        dest: '~/.kube/config'
        mode: '0600'

    - name: Set owner and group for ~/.kube/config
      shell: |
        chown $(id -u):$(id -g) ~/.kube/config
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"

    - name: Get the join command
      command: kubeadm token create --print-join-command
      register: _result_join_command
      changed_when: "_result_join_command.rc == 0"

    - name: Set eks_join_command fact
      set_fact:
        eks_join_command: "{{ _result_join_command.stdout }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

    - name: Storing the join cluster command token.
      copy:
        content: "{{ _result_join_command.stdout }}"
        dest: ~/eks_token
        mode: '0644'

    - name: Read in the coredns config
      kubernetes.core.k8s_info:
        api_key: "{{ api_key | default(omit) }}"
        kubeconfig: ~/.kube/config
        api_version: v1
        kind: ConfigMap
        name: coredns
        namespace: kube-system
        wait: true
      register: _result_coredns
      delay: 30
      retries: 60
      until: _result_coredns.resources is defined and _result_coredns.resources | length > 0

    - when: (_result_coredns.resources | selectattr('metadata.name','==','coredns') | map(attribute='data.Corefile') | first | regex_replace('\n','|')) is match('.* /etc/resolv.conf .*')
      block:

        - name: Update the coredns config
          kubernetes.core.k8s:
            api_key: "{{ api_key | default(omit) }}"
            kubeconfig: ~/.kube/config
            definition: "{{ coredns_configmap | regex_replace('/etc/resolv.conf','8.8.8.8') }}"
          register: _result

        - name: Run the run-deploy.sh command
          command: |
            kubectl --kubeconfig ~/.kube/config rollout restart -n kube-system deployment coredns
          register: _result

      vars:
        coredns_configmap: "{{ _result_coredns.resources | selectattr('metadata.name','==','coredns') | first }}"

    - name: Install Network Add-on
      ansible.builtin.command: kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/canal.yaml
      register: _result
      changed_when: "_result.rc == 0"

- when: inventory_hostname in groups['master_nodes'][1:]
  name: Setup the remaining master nodes
  block:

    - name: Check for existing ~/eks_controller_join_command.sh
      stat:
        path: ~/eks_controller_join_command.sh
      register: _result

    - when: not _result.stat.exists
      name: Join additional controller nodes using the PK
      ansible.builtin.shell: |
        kubeadm reset -f || true
        echo "{{ hostvars['k8s-provisioner']['eks_join_command'] }} {{ hostvars['k8s-provisioner']['eks_controller_join_key'] }}" > ~/eks_controller_join_command.sh
        sh ~/eks_controller_join_command.sh
      args:
        executable: /bin/bash
      environment:
        HTTP_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
        HTTPS_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
        NO_PROXY: "localhost,127.0.0.1,0.0.0.0,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.local,.svc"
      changed_when: false

    - name: Create kube directory
      ansible.builtin.file:
        path: ~/.kube
        state: directory
        mode: '0777'

    - name: Copying required files
      ansible.builtin.shell: |
        cp -f /etc/kubernetes/admin.conf ~/.kube/config
        chown $(id -u):$(id -g) ~/.kube/config
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"

- when: inventory_hostname in groups['worker_nodes']
  name: Setup the remaining cluster nodes
  block:

    - name: Check for existing ~/eks_compute_join_command.sh
      stat:
        path: ~/eks_compute_join_command.sh
      register: _result

    - when: not _result.stat.exists
      name: Join compute nodes with kubernetes control plane
      ansible.builtin.shell: |
        kubeadm reset -f || true
        echo "{{ hostvars['k8s-provisioner']['eks_join_command'] }}" > ~/eks_compute_join_command.sh
        sh ~/eks_compute_join_command.sh
      args:
        executable: /bin/bash
      environment:
        HTTP_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
        HTTPS_PROXY: "{{ 'http://registry-proxy.' + k8s_infra_privateip + '.nip.io:3128' }}"
        NO_PROXY: "localhost,127.0.0.1,0.0.0.0,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.local,.svc"
      changed_when: false

- when: inventory_hostname == groups['master_nodes'][0]
  name: Setup specific to the first server node of the control plane
  block:

    - name: Fetch the kubeconfig from the first controller node
      ansible.builtin.slurp:
        src: ~/.kube/config
      register: _result_cluster_kubeconfig

    - name: Set eks_kubeconfig fact
      set_fact:
        eks_kubeconfig: "{{ _result_cluster_kubeconfig.content | b64decode }}"
      delegate_to: 'k8s-provisioner'
      delegate_facts: true

- when: inventory_hostname == k8s_infra_hostname
  name: Complete the setup of the infra node
  block:

    - name: Create kube directory
      ansible.builtin.file:
        path: ~/.kube
        state: directory
        mode: '0644'

    - name: Store the kubeconfig to the provision services machine.
      ansible.builtin.copy:
        content: "{{ hostvars['k8s-provisioner']['eks_kubeconfig'] }}"
        dest: ~/.kube/config
        mode: '0644'

    - name: Label compute nodes
      ansible.builtin.shell: |
        kubectl label node {{ hostvars[item].fqdn }} node-role.kubernetes.io/worker=
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"
      loop: "{{ groups['worker_nodes'] | default([]) }}"

    #- name: Allow schedule workloads in controller nodes if there are no compute nodes
    #  ansible.builtin.shell: |
    #    set -eo pipefail
    #    # Deprecated in 1.24
    #    for node in $(kubectl get nodes -o json | jq -r '.items[] | select(.spec.taints[]?.key=="node-role.kubernetes.io/master") | .metadata.labels."kubernetes.io/hostname"');
    #    do
    #      kubectl taint node ${node} node-role.kubernetes.io/master:NoSchedule-
    #    done
    #    # Working starting on 1.24
    #    for node in $(kubectl get nodes -o json | jq -r '.items[] | select(.spec.taints[]?.key=="node-role.kubernetes.io/control-plane") | .metadata.labels."kubernetes.io/hostname"');
    #    do
    #      kubectl taint node ${node} node-role.kubernetes.io/control-plane:NoSchedule-
    #    done
    #  args:
    #    executable: /bin/bash
    #  register: _result
    #  changed_when: "_result.rc == 0"
    #  when: not kubeinit_compute_count|int > 0

    #- name: Install kustomize
    #  ansible.builtin.shell: |
    #    curl -sL https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.1.0/kustomize_v5.1.0_linux_amd64.tar.gz > kustomize.tar.gz
    #    tar xzf ./kustomize.tar.gz
    #    mv ./kustomize /bin/
    #  args:
    #    executable: /bin/bash
    #  register: _result
    #  changed_when: "_result.rc == 0"
    #  delegate_to: "{{ kubeinit_provision_service_node }}"

    - name: Deploy EKS manifests
      ansible.builtin.shell: |
        kubectl apply -f https://distro.eks.amazonaws.com/crds/releases.distro.eks.amazonaws.com-v1alpha1.yaml
        kubectl apply -f {{ hostvars['k8s-provisioner']['eks_distro_url'] }}
        kubectl get release kubernetes-{{ hostvars['k8s-provisioner']['eks_major_minor_revision'] }}
        kubectl get release kubernetes-{{ hostvars['k8s-provisioner']['eks_major_minor_revision'] }} -o yaml
      args:
        executable: /bin/bash
      register: _result
      changed_when: "_result.rc == 0"
